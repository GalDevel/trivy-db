// Code generated by mockery v1.0.0. DO NOT EDIT.

package db

import bbolt "github.com/etcd-io/bbolt"
import mock "github.com/stretchr/testify/mock"
import types "github.com/aquasecurity/trivy-db/pkg/types"

// MockOperations is an autogenerated mock type for the Operations type
type MockOperations struct {
	mock.Mock
}

type BatchUpdateArgs struct {
	_a0         func(*bbolt.Tx) error
	_a0Anything bool
}

type BatchUpdateReturns struct {
	_a0 error
}

type BatchUpdateExpectation struct {
	Args    BatchUpdateArgs
	Returns BatchUpdateReturns
}

func (_m *MockOperations) ApplyBatchUpdateExpectation(e BatchUpdateExpectation) {
	var args []interface{}
	if e.Args._a0Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a0)
	}
	_m.On("BatchUpdate", args...).Return(e.Returns._a0)
}

func (_m *MockOperations) ApplyBatchUpdateExpectations(expectations []BatchUpdateExpectation) {
	for _, e := range expectations {
		_m.ApplyBatchUpdateExpectation(e)
	}
}

// BatchUpdate provides a mock function with given fields: _a0
func (_m *MockOperations) BatchUpdate(_a0 func(*bbolt.Tx) error) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*bbolt.Tx) error) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type DeleteSeverityBucketReturns struct {
	_a0 error
}

type DeleteSeverityBucketExpectation struct {
	Returns DeleteSeverityBucketReturns
}

func (_m *MockOperations) ApplyDeleteSeverityBucketExpectation(e DeleteSeverityBucketExpectation) {
	var args []interface{}
	_m.On("DeleteSeverityBucket", args...).Return(e.Returns._a0)
}

func (_m *MockOperations) ApplyDeleteSeverityBucketExpectations(expectations []DeleteSeverityBucketExpectation) {
	for _, e := range expectations {
		_m.ApplyDeleteSeverityBucketExpectation(e)
	}
}

// DeleteSeverityBucket provides a mock function with given fields:
func (_m *MockOperations) DeleteSeverityBucket() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type DeleteVulnerabilityDetailBucketReturns struct {
	_a0 error
}

type DeleteVulnerabilityDetailBucketExpectation struct {
	Returns DeleteVulnerabilityDetailBucketReturns
}

func (_m *MockOperations) ApplyDeleteVulnerabilityDetailBucketExpectation(e DeleteVulnerabilityDetailBucketExpectation) {
	var args []interface{}
	_m.On("DeleteVulnerabilityDetailBucket", args...).Return(e.Returns._a0)
}

func (_m *MockOperations) ApplyDeleteVulnerabilityDetailBucketExpectations(expectations []DeleteVulnerabilityDetailBucketExpectation) {
	for _, e := range expectations {
		_m.ApplyDeleteVulnerabilityDetailBucketExpectation(e)
	}
}

// DeleteVulnerabilityDetailBucket provides a mock function with given fields:
func (_m *MockOperations) DeleteVulnerabilityDetailBucket() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type ForEachAdvisoryArgs struct {
	_a0         string
	_a0Anything bool
	_a1         string
	_a1Anything bool
}

type ForEachAdvisoryReturns struct {
	_a0 map[string][]byte
	_a1 error
}

type ForEachAdvisoryExpectation struct {
	Args    ForEachAdvisoryArgs
	Returns ForEachAdvisoryReturns
}

func (_m *MockOperations) ApplyForEachAdvisoryExpectation(e ForEachAdvisoryExpectation) {
	var args []interface{}
	if e.Args._a0Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a0)
	}
	if e.Args._a1Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a1)
	}
	_m.On("ForEachAdvisory", args...).Return(e.Returns._a0, e.Returns._a1)
}

func (_m *MockOperations) ApplyForEachAdvisoryExpectations(expectations []ForEachAdvisoryExpectation) {
	for _, e := range expectations {
		_m.ApplyForEachAdvisoryExpectation(e)
	}
}

// ForEachAdvisory provides a mock function with given fields: _a0, _a1
func (_m *MockOperations) ForEachAdvisory(_a0 string, _a1 string) (map[string][]byte, error) {
	ret := _m.Called(_a0, _a1)

	var r0 map[string][]byte
	if rf, ok := ret.Get(0).(func(string, string) map[string][]byte); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type ForEachSeverityArgs struct {
	F         func(*bbolt.Tx, string, types.Severity) error
	FAnything bool
}

type ForEachSeverityReturns struct {
	_a0 error
}

type ForEachSeverityExpectation struct {
	Args    ForEachSeverityArgs
	Returns ForEachSeverityReturns
}

func (_m *MockOperations) ApplyForEachSeverityExpectation(e ForEachSeverityExpectation) {
	var args []interface{}
	if e.Args.FAnything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args.F)
	}
	_m.On("ForEachSeverity", args...).Return(e.Returns._a0)
}

func (_m *MockOperations) ApplyForEachSeverityExpectations(expectations []ForEachSeverityExpectation) {
	for _, e := range expectations {
		_m.ApplyForEachSeverityExpectation(e)
	}
}

// ForEachSeverity provides a mock function with given fields: f
func (_m *MockOperations) ForEachSeverity(f func(*bbolt.Tx, string, types.Severity) error) error {
	ret := _m.Called(f)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*bbolt.Tx, string, types.Severity) error) error); ok {
		r0 = rf(f)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type GetAdvisoriesArgs struct {
	_a0         string
	_a0Anything bool
	_a1         string
	_a1Anything bool
}

type GetAdvisoriesReturns struct {
	_a0 []types.Advisory
	_a1 error
}

type GetAdvisoriesExpectation struct {
	Args    GetAdvisoriesArgs
	Returns GetAdvisoriesReturns
}

func (_m *MockOperations) ApplyGetAdvisoriesExpectation(e GetAdvisoriesExpectation) {
	var args []interface{}
	if e.Args._a0Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a0)
	}
	if e.Args._a1Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a1)
	}
	_m.On("GetAdvisories", args...).Return(e.Returns._a0, e.Returns._a1)
}

func (_m *MockOperations) ApplyGetAdvisoriesExpectations(expectations []GetAdvisoriesExpectation) {
	for _, e := range expectations {
		_m.ApplyGetAdvisoriesExpectation(e)
	}
}

// GetAdvisories provides a mock function with given fields: _a0, _a1
func (_m *MockOperations) GetAdvisories(_a0 string, _a1 string) ([]types.Advisory, error) {
	ret := _m.Called(_a0, _a1)

	var r0 []types.Advisory
	if rf, ok := ret.Get(0).(func(string, string) []types.Advisory); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Advisory)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type GetSeverityArgs struct {
	_a0         string
	_a0Anything bool
}

type GetSeverityReturns struct {
	_a0 types.Severity
	_a1 error
}

type GetSeverityExpectation struct {
	Args    GetSeverityArgs
	Returns GetSeverityReturns
}

func (_m *MockOperations) ApplyGetSeverityExpectation(e GetSeverityExpectation) {
	var args []interface{}
	if e.Args._a0Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a0)
	}
	_m.On("GetSeverity", args...).Return(e.Returns._a0, e.Returns._a1)
}

func (_m *MockOperations) ApplyGetSeverityExpectations(expectations []GetSeverityExpectation) {
	for _, e := range expectations {
		_m.ApplyGetSeverityExpectation(e)
	}
}

// GetSeverity provides a mock function with given fields: _a0
func (_m *MockOperations) GetSeverity(_a0 string) (types.Severity, error) {
	ret := _m.Called(_a0)

	var r0 types.Severity
	if rf, ok := ret.Get(0).(func(string) types.Severity); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(types.Severity)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type GetVulnerabilityArgs struct {
	_a0         string
	_a0Anything bool
}

type GetVulnerabilityReturns struct {
	_a0 types.Vulnerability
	_a1 error
}

type GetVulnerabilityExpectation struct {
	Args    GetVulnerabilityArgs
	Returns GetVulnerabilityReturns
}

func (_m *MockOperations) ApplyGetVulnerabilityExpectation(e GetVulnerabilityExpectation) {
	var args []interface{}
	if e.Args._a0Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a0)
	}
	_m.On("GetVulnerability", args...).Return(e.Returns._a0, e.Returns._a1)
}

func (_m *MockOperations) ApplyGetVulnerabilityExpectations(expectations []GetVulnerabilityExpectation) {
	for _, e := range expectations {
		_m.ApplyGetVulnerabilityExpectation(e)
	}
}

// GetVulnerability provides a mock function with given fields: _a0
func (_m *MockOperations) GetVulnerability(_a0 string) (types.Vulnerability, error) {
	ret := _m.Called(_a0)

	var r0 types.Vulnerability
	if rf, ok := ret.Get(0).(func(string) types.Vulnerability); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(types.Vulnerability)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type PutAdvisoryArgs struct {
	_a0         *bbolt.Tx
	_a0Anything bool
	_a1         string
	_a1Anything bool
	_a2         string
	_a2Anything bool
	_a3         string
	_a3Anything bool
	_a4         interface{}
	_a4Anything bool
}

type PutAdvisoryReturns struct {
	_a0 error
}

type PutAdvisoryExpectation struct {
	Args    PutAdvisoryArgs
	Returns PutAdvisoryReturns
}

func (_m *MockOperations) ApplyPutAdvisoryExpectation(e PutAdvisoryExpectation) {
	var args []interface{}
	if e.Args._a0Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a0)
	}
	if e.Args._a1Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a1)
	}
	if e.Args._a2Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a2)
	}
	if e.Args._a3Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a3)
	}
	if e.Args._a4Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a4)
	}
	_m.On("PutAdvisory", args...).Return(e.Returns._a0)
}

func (_m *MockOperations) ApplyPutAdvisoryExpectations(expectations []PutAdvisoryExpectation) {
	for _, e := range expectations {
		_m.ApplyPutAdvisoryExpectation(e)
	}
}

// PutAdvisory provides a mock function with given fields: _a0, _a1, _a2, _a3, _a4
func (_m *MockOperations) PutAdvisory(_a0 *bbolt.Tx, _a1 string, _a2 string, _a3 string, _a4 interface{}) error {
	ret := _m.Called(_a0, _a1, _a2, _a3, _a4)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, string, string, interface{}) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3, _a4)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type PutSeverityArgs struct {
	_a0         *bbolt.Tx
	_a0Anything bool
	_a1         string
	_a1Anything bool
	_a2         types.Severity
	_a2Anything bool
}

type PutSeverityReturns struct {
	_a0 error
}

type PutSeverityExpectation struct {
	Args    PutSeverityArgs
	Returns PutSeverityReturns
}

func (_m *MockOperations) ApplyPutSeverityExpectation(e PutSeverityExpectation) {
	var args []interface{}
	if e.Args._a0Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a0)
	}
	if e.Args._a1Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a1)
	}
	if e.Args._a2Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a2)
	}
	_m.On("PutSeverity", args...).Return(e.Returns._a0)
}

func (_m *MockOperations) ApplyPutSeverityExpectations(expectations []PutSeverityExpectation) {
	for _, e := range expectations {
		_m.ApplyPutSeverityExpectation(e)
	}
}

// PutSeverity provides a mock function with given fields: _a0, _a1, _a2
func (_m *MockOperations) PutSeverity(_a0 *bbolt.Tx, _a1 string, _a2 types.Severity) error {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, types.Severity) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type PutVulnerabilityArgs struct {
	_a0         *bbolt.Tx
	_a0Anything bool
	_a1         string
	_a1Anything bool
	_a2         types.Vulnerability
	_a2Anything bool
}

type PutVulnerabilityReturns struct {
	_a0 error
}

type PutVulnerabilityExpectation struct {
	Args    PutVulnerabilityArgs
	Returns PutVulnerabilityReturns
}

func (_m *MockOperations) ApplyPutVulnerabilityExpectation(e PutVulnerabilityExpectation) {
	var args []interface{}
	if e.Args._a0Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a0)
	}
	if e.Args._a1Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a1)
	}
	if e.Args._a2Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a2)
	}
	_m.On("PutVulnerability", args...).Return(e.Returns._a0)
}

func (_m *MockOperations) ApplyPutVulnerabilityExpectations(expectations []PutVulnerabilityExpectation) {
	for _, e := range expectations {
		_m.ApplyPutVulnerabilityExpectation(e)
	}
}

// PutVulnerability provides a mock function with given fields: _a0, _a1, _a2
func (_m *MockOperations) PutVulnerability(_a0 *bbolt.Tx, _a1 string, _a2 types.Vulnerability) error {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, types.Vulnerability) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type PutVulnerabilityDetailArgs struct {
	_a0         *bbolt.Tx
	_a0Anything bool
	_a1         string
	_a1Anything bool
	_a2         string
	_a2Anything bool
	_a3         types.VulnerabilityDetail
	_a3Anything bool
}

type PutVulnerabilityDetailReturns struct {
	_a0 error
}

type PutVulnerabilityDetailExpectation struct {
	Args    PutVulnerabilityDetailArgs
	Returns PutVulnerabilityDetailReturns
}

func (_m *MockOperations) ApplyPutVulnerabilityDetailExpectation(e PutVulnerabilityDetailExpectation) {
	var args []interface{}
	if e.Args._a0Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a0)
	}
	if e.Args._a1Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a1)
	}
	if e.Args._a2Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a2)
	}
	if e.Args._a3Anything {
		args = append(args, mock.Anything)
	} else {
		args = append(args, e.Args._a3)
	}
	_m.On("PutVulnerabilityDetail", args...).Return(e.Returns._a0)
}

func (_m *MockOperations) ApplyPutVulnerabilityDetailExpectations(expectations []PutVulnerabilityDetailExpectation) {
	for _, e := range expectations {
		_m.ApplyPutVulnerabilityDetailExpectation(e)
	}
}

// PutVulnerabilityDetail provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *MockOperations) PutVulnerabilityDetail(_a0 *bbolt.Tx, _a1 string, _a2 string, _a3 types.VulnerabilityDetail) error {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, string, types.VulnerabilityDetail) error); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
