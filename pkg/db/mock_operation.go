// Code generated by mockery v1.0.0. DO NOT EDIT.

package db

import (
	bbolt "github.com/etcd-io/bbolt"
	mock "github.com/stretchr/testify/mock"

	types "github.com/aquasecurity/trivy-db/pkg/types"
)

// MockOperation is an autogenerated mock type for the Operation type
type MockOperation struct {
	mock.Mock
}

// BatchUpdate provides a mock function with given fields: fn
func (_m *MockOperation) BatchUpdate(fn func(*bbolt.Tx) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*bbolt.Tx) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteSeverityBucket provides a mock function with given fields:
func (_m *MockOperation) DeleteSeverityBucket() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteVulnerabilityDetailBucket provides a mock function with given fields:
func (_m *MockOperation) DeleteVulnerabilityDetailBucket() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ForEachAdvisory provides a mock function with given fields: source, pkgName
func (_m *MockOperation) ForEachAdvisory(source string, pkgName string) (map[string][]byte, error) {
	ret := _m.Called(source, pkgName)

	var r0 map[string][]byte
	if rf, ok := ret.Get(0).(func(string, string) map[string][]byte); ok {
		r0 = rf(source, pkgName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(source, pkgName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ForEachSeverity provides a mock function with given fields: fn
func (_m *MockOperation) ForEachSeverity(fn func(*bbolt.Tx, string, types.Severity) error) error {
	ret := _m.Called(fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(func(*bbolt.Tx, string, types.Severity) error) error); ok {
		r0 = rf(fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAdvisories provides a mock function with given fields: source, pkgName
func (_m *MockOperation) GetAdvisories(source string, pkgName string) ([]types.Advisory, error) {
	ret := _m.Called(source, pkgName)

	var r0 []types.Advisory
	if rf, ok := ret.Get(0).(func(string, string) []types.Advisory); ok {
		r0 = rf(source, pkgName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Advisory)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(source, pkgName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSeverity provides a mock function with given fields: vulnerabilityID
func (_m *MockOperation) GetSeverity(vulnerabilityID string) (types.Severity, error) {
	ret := _m.Called(vulnerabilityID)

	var r0 types.Severity
	if rf, ok := ret.Get(0).(func(string) types.Severity); ok {
		r0 = rf(vulnerabilityID)
	} else {
		r0 = ret.Get(0).(types.Severity)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(vulnerabilityID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVulnerability provides a mock function with given fields: vulnerabilityID
func (_m *MockOperation) GetVulnerability(vulnerabilityID string) (types.Vulnerability, error) {
	ret := _m.Called(vulnerabilityID)

	var r0 types.Vulnerability
	if rf, ok := ret.Get(0).(func(string) types.Vulnerability); ok {
		r0 = rf(vulnerabilityID)
	} else {
		r0 = ret.Get(0).(types.Vulnerability)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(vulnerabilityID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutAdvisory provides a mock function with given fields: tx, source, pkgName, vulnerabilityID, advisory
func (_m *MockOperation) PutAdvisory(tx *bbolt.Tx, source string, pkgName string, vulnerabilityID string, advisory interface{}) error {
	ret := _m.Called(tx, source, pkgName, vulnerabilityID, advisory)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, string, string, interface{}) error); ok {
		r0 = rf(tx, source, pkgName, vulnerabilityID, advisory)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PutSeverity provides a mock function with given fields: tx, vulnerabilityID, severity
func (_m *MockOperation) PutSeverity(tx *bbolt.Tx, vulnerabilityID string, severity types.Severity) error {
	ret := _m.Called(tx, vulnerabilityID, severity)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, types.Severity) error); ok {
		r0 = rf(tx, vulnerabilityID, severity)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PutVulnerability provides a mock function with given fields: tx, vulnerabilityID, vulnerability
func (_m *MockOperation) PutVulnerability(tx *bbolt.Tx, vulnerabilityID string, vulnerability types.Vulnerability) error {
	ret := _m.Called(tx, vulnerabilityID, vulnerability)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, types.Vulnerability) error); ok {
		r0 = rf(tx, vulnerabilityID, vulnerability)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PutVulnerabilityDetail provides a mock function with given fields: tx, vulnerabilityID, source, vulnerability
func (_m *MockOperation) PutVulnerabilityDetail(tx *bbolt.Tx, vulnerabilityID string, source string, vulnerability types.VulnerabilityDetail) error {
	ret := _m.Called(tx, vulnerabilityID, source, vulnerability)

	var r0 error
	if rf, ok := ret.Get(0).(func(*bbolt.Tx, string, string, types.VulnerabilityDetail) error); ok {
		r0 = rf(tx, vulnerabilityID, source, vulnerability)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
